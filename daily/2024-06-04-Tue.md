# CS50- 문자열
문자열 “mrho”를 저장한다고 생각해보자.

```c
string s = "mrho";
```

흔히 문자열 변수 s에 “mrho”를 담는다. 라고 생각합니다.

**문자열은 문자들의 모음, 즉 문자 배열입니다.**

“hoho”를 메모리 상에 나타내면 다음과 같습니다.

<img width="506" alt="1" src="https://github.com/devhoody/TIL/assets/124743189/9bbb173d-c287-4439-b92e-4c6ea99f692d">
변수 s는 여기서 “m”의 주소, x001을 담고 있습니다.

어디서 많이 보지 않았나요?

주소를 담는 변수, 포인터입니다.

변수 s는 포인터가 됩니다.

그래서 “문자열은 포인터다.”라는 말이 나오는 겁니다.

String s 를 char *s 로 표현하는 것도 가능해지는 겁니다.

```c
string s = "mrho";
char *s = "mrho";
```

### string을 이용한 “mrho” 출력

```c
int main(void) 
{
	string s = "mrho";
	printf("%s\n", s);
}
```

### char 포인터를 이용한 “mrho” 출력

```c
int main(void) 
{
	char *s = "mrho";
	printf("%s\n", s);
}
```

만약 여기서 s의 메모리 주소 (=“m”의 주소)를 출력하고자 한다면 %p를 이용하면 됩니다.

```c
int main(void) 
{
	char *s = "mrho";
	printf("%p\n", s);
}
```

# 문자열 비교

이번에는 “mrho”의 각각의 단어를 출력해봅시다.

먼저 문자 배열 인덱스를 이용한 출력입니다.

```c
printf("%c\n", *s[0]);
printf("%c\n", *s[1]);
printf("%c\n", *s[2]);
printf("%c\n", *s[3]);
```

이번에는 주소를 이용하여 출력해봅니다.

```c
printf("%c\n", *s);
printf("%c\n", *(s+1));
printf("%c\n", *(s+2));
printf("%c\n", *(s+3));
```

s의 주소 x001에서 +1을 한 바로 다음 주소의 값이 출력되는 것을 알 수 있습니다.

두 문자열을 받아 같은지 다른지 비교하려면 다음과 같이 작성합니다.

```c
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    // 사용자로부터 s와 t 두 개의 문자열 입력받아 저장
    string s = get_string("s: ");
    string t = get_string("t: ");

    // 두 문자열을 비교 (각 문자들을 비교)
    if (s == t)
    {
        printf("Same\n");
    }
    else
    {
        printf("Different\n");
    }
}
```

문자열 s와 t 모두 “mrho”를 입력받았다고 가정해봅시다.

둘다 “mrho”로 똑같으니 Same이 출력되어야할겁니다.

하지만, 결과는 Different가 나오게됩니다.

이유는?

문자열 변수는 뭐라고했죠? 위에서 포인터라고 했습니다.

즉, 주소를 갖고있는 변수죠.

문자열 입력을 따로 받기때문에 메모리에 할당된 주소도 다르게 입력 받습니다.

그래서 두 주소를 비교했을때, 다르다는 결과가 나오는 것이죠.

문자열 s에 담긴 “mrho”의 메모리 주소가 x001, t에 담긴 “mrho”의 메모리 주소는 x006가 된다는 이야기였습니다.

<img width="711" alt="2" src="https://github.com/devhoody/TIL/assets/124743189/80053b99-812d-4ae8-9946-4cbd59ac4f5c">

# 문자열 복사

우선 머릿속에 때려넣고 이해해봅시다.

> 모든 변수의 값은 복사되어 대입된다.
>

무슨소리냐구요?

아래 코드를 보면서 이해해보겠습니다.

```c
#include <cs50.h>
#include <ctype.h>
#include <stdio.h>

int main(void)
{
    string s = get_string("s: ");
    string t = s;

    t[0] = toupper(t[0]);

    printf("s: %s\n", s);
    printf("t: %s\n", t);
}
```

문자열 s에 “ho”를 입력한다고 가정해보겠습니다.

s의 값이 t로 담기게 되고 t의 첫문자 ‘h’를 대문자 ‘H’로 변경한 후, 출력합니다.

결과는 각각 “Ho” , “Ho”가 출력됩니다.

엥? 난 s를 대문자로 바꾼적이 없는데? 하시는 분이 계실것 같습니다.

자, 위에서 말씀드렸듯이 문자열 변수는 뭐라고했죠? 네 포인터입니다. 메모리 주소를 담는다는 것이죠.

문자열 s에는 “ho”가 할당된 메모리 주소 x001이 담깁니다.

문자열 t에는 s의 주소 x001이 복사되어 들어가게됩니다.

머릿속에 때려 박으라는 것이 “모든 변수의 값은 복사되어 대입된다.” 였죠?

여기서 그 기억이 사용되는 것입니다ㅎ

복사된 x001의 주소가 t에 들어가니 s와 t모두 x001의 같은 메모리 주소를 가리키고 있습니다.

따라서, t의 첫번째 문자를 대문자로 변환하면, s가 가리키고 있는 첫번째 문자도 대문자가 되어있는 것입니다.

자바에서는 **같은 객체를 참조하고있다.** 라고도 합니다.

(저는 자바 유저입니다ㅎ)

## 다른 메모리 주소에 문자열을 복사하는 방법

여기서는 할당의 개념이 들어갑니다.

메모리 주소를 할당한다는 이야기지요.

C언어에서는 메모리 주소를 할당하는 메서드가 있습니다.

바로 “malloc” 입니다.

밑의 코드를 보면서 설명드리겠습니다.

```c
#include <cs50.h>
#include <ctype.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    char *s = get_string("s: ");
    char *t = malloc(strlen(s) + 1);

    for (int i = 0, n = strlen(s); i < n + 1; i++)
    {
        t[i] = s[i];
    }

    t[0] = toupper(t[0]);

    printf("s: %s\n", s);
    printf("t: %s\n", t);
}
```

이번엔 char *s, char *t로 문자열을 받네요.

char *t는 malloc을 이용해 메모리 공간을 할당받습니다.

strlen(s)는 문자열 길이를 나타내는 것으로 (입력받은 문자열 s의 길이 +1) 만큼의 공간을 할당받네요.

이렇게 malloc을 이용하면 지정한 크기만큼 간단하게 메모리 공간을 할당받을 수 있습니다.

여기서 퀴즈!

왜 메모리 공간 크기를 문자열 길이가 아닌 문자열 길이+1을 할까요?

정답은 널 종단 문자입니다.

문자열에는 끝을 알려주는 널 종단 문자가 있어야합니다.

그래서 널 종단 문자(\0)의 공간까지 마련해주기 위해 +1을 해주는 것입니다.

만약 없다면.. 널 종단 문자를 찾아서 메모리의 끝까지 계속 여행을 떠날 겁니다.

이제 t에 문자열 s의 각 문자를 복사하여 대입해주고

값을 출력하면 각각 다른 메모리 주소에 같은 문자열을 갖게 되는 것을 알 수 있습니다.


# 코딩테스트
- 하노이의 탑