# Http

### 캐시란?

- 브라우저 내 저장소

### 캐시를 사용하는 이유

- 자주 사용하는 데이터가 클 경우, 서버에서 계속 요청하는게 부담스러움
- 네트워크 리소스가 비쌈

### 캐시 사용 방법

- 처음 요청
    - 서버에서 응답 메시지에 캐시 만료 기간을 넣음 → cach-control
    - 클라이언트는 서버에서 받은 데이터를 캐시에 저장
- 두번째 요청 이후
    - 다시 같은 데이터를 요청할 때, 캐시부터 검색해서 있으면 사용

# 검증 헤더

- 캐시 유효 기간이 만료된 후, 같은 데이터를 요청할 때 변한게 없다면? 캐시에 있는 데이터 그대로 사용 가능
- 변한게 없는지를 서버에 검증받아야한다. 이때 사용하는게 검증 헤더이다.

## last-modified

- 가장 최근 수정일
- 처음 요청 시, 응답메시지에 last-modified로 최근 수정 날짜 보냄
- 캐시에 최근 수정일 포함 데이터 저장
- 캐시 저장 데이터가 만료되어 요청 메시지에 last-modified 포함해서 서버에 보냄
- 서버는 갖고있는 데이터의 last-modified를 확인해서 변경 여부 보냄
    - 변경 시 : 200 + http 바디에 데이터 담아서 전송
    - 변경 안될 경우 : 304 Not Modified + http 헤더만 전송 ( http 바디는 비어있음)

## ETag

서버에서 캐시 제어 로직을 관리한다.

- 만약, 데이터의 변경 상태가 A → B → A 처럼 다시 똑같아질 경우, 데이터는 같은데 최근 수정일이 달라 다시 보내는 경우가 발생한다.
- 이를 해결하는 것이 ETag

### ETag 방법

- **`데이터 버전을 비교`**하여 변경 여부를 판단한다.
- 애플리케이션 배포 버젼이 달라질 경우, 변경하는 방법이 있다.

# 캐시 제어 헤더

## Cache - Control

- **max-age** : 캐시 유효 시간, 초단위
- **no-cache** : 무조건 서버에 검증 후 캐시 데이터 사용
- **no-store** : 캐시 데이터 저장 안됌. 중요함!

## 프록시 캐시

- 한국에 있는 클라이언트가 미국에 있는 원서버에 직접 데이터를 주고받는데 너무 오래걸림. (500ms)
- 그 사이에 한국에 프록시 캐시 서버를 두고 한국 클라이언트가 빠르게 데이터를 주고 받을 수 있도록 함(100ms)
- 클라이언트는 private 캐시이고 프록시 캐시 서버를 public 캐시라고 한다.

## 캐시 무효화

- 브라우저는 임의로 데이터를 캐시에 저장한다. 민감정보의 경우 저장을 못하도록 막아야한다.
- 사용 방법
    
    <aside>
    💡 캐시 무효화 무적 세팅
    
    Cache-Control : no-cache, no-store, must-revalidate
    
    Pragma : no-cache
    
    </aside>
    
    - Pragma : http 1.0버전 이전의 Cache-Control 역할

### no-cache vs must-revalidate

must-revalidate와 no-cache는 모두 무조건 원서버에 검증을 해야한다는 공통점이 있다.

차이점은 아래와 같다.

**프록시 캐시 서버와 원서버간의 통신이 끊어질 경우**에 따라서 차이가 발생한다.

no-cache : 통신이 끊어질 경우, 프록시 서버에서 데이터를 대신 보내줌

must-revalidate : 통신이 끊어질 경우, 항상 오류 발생

# 스프링 - 로그인 세션

## 세션이란?

- 데이터마다 매칭한 값

## 세션을 사용하는 이유

- 쿠키의 단점을 보완하기 위해서 절대 맞출 수 없는 객체 고유의 인증 번호를 만든다. 개인 정보를 해킹할 수 없도록!
- 객체에 접근하려면 인증 번호가 필요하다.

### 쿠키의 단점

- 브라우저에서 임의로 변경이 가능하다.
- 한번 훔치면 영구적으로 사용 가능하다.

# 세션 사용 방법

HttpSession을 사용하자.

## HttpSesion

### HttpSession이란?

- http 메시지의 Session과 관련된 정보를 담당하는 클래스

### HttpSession 메서드

**getSession()** : HttpServletRequest에서 세션 정보를 불러온다.

```java
getSession(true) // 기본값, 세션이 있으면 조회하고 없으면 새로 생성한다.
getSession(false) // 세션이 있으면 조회하고 없으면 null을 반환한다.
```

**HttpSession.setAttribute(세션 이름, 객체)** : 세션 ID와 객체를 매칭하여 저장한다.

세션 만료

**HttpSession.invalidated()**

## 홈과 로그인 홈 분리

- 로그인을 안할 때의 홈페이지와 로그인 시 홈페이지를 분리한다.
- 로그인 시 닉네임과 개인 정보가 보이는 홈페이지가 이 경우에 해당한다.

## @SessionAttribute

- 기존에 HttpSession을 이용해서 request에 있는 세션을 불러오고 세션 정보와 매칭한 객체를 불러오는 작업을 일일이 했다면, 이를 한번에 해결해주는 애노테이션이다.
- 로그인한 페이지 보여줄 때 사용

### 사용 방법

```java
public String loginHome(@SessionAttribute(name ="", required = false) 객체 명)
```

### 왜 false??

- 로그인한 페이지를 보여주는 경우, 로그인할 때 받은 세션을 이용해야한다. 만약, 로그인을 하지 않은 사용자가 세션을 새로 받게되면 로그인을 하지 않더라도 로그인한 페이지로 이동하게 된다.

## 처음 로그인시 URL에 sessionId 붙는거 막기

붙는 이유

브라우저가 쿠키를 지원하지 않을 때, 세션 정보를 담기위해서 URL에 붙여 사용

## 세션 만료기간 설정

### 세션 만료기간 설정 이유

- 사용자가 로그아웃을 해야 세션을 만료시킬 수 있다. 하지만, 사용자가 로그아웃을 하지 않고 브라우저를 닫아버리면 서버는 닫은지 알수 없다. 왜냐하면 http는 비연결성이므로 클라이언트와 서버는 요청시에만 연결되었다가 끊어지기 떄문이다. 일정 시간이 지나면 세션이 알아서 만료되도록 만료 기간을 설정한다.

### 세션 만료기간 설정 방법

글로벌 만료 기간 설정과, 지역적인 기간 설정이 있다.

- 글로벌 만료 기간 설정 : **application.properties** 사용

```java
server.servlet.session.timeout=1800 // 초단위, 30분
```

- 지역 만료 기간 설정 : **HttpSession.setInactiveIntaval()**

# 코딩테스트

- [lv1 - 옹알이 (2)](https://school.programmers.co.kr/learn/courses/30/lessons/133499)